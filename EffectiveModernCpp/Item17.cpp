#include <iostream>


class onlyDestructor{
public:
    onlyDestructor(){
        q = new int{100};
    }
    ~onlyDestructor(){
        std::cout << *q << '\n';
        delete q;
        q = nullptr;
    }
private:
    int* q;
};

int main()
{
    //Item17.理解特殊成员函数的生成

    //默认构造函数： 仅当类不存在用户定义的构造函数时自动生成
    //析构函数： 和构造函数一样，不过析构函数默认noexcept，并且仅当基类析构函数是虚函数时该类析构函数才会声明成virtual
    //拷贝构造函数：和C++98运行时行为一样：逐成员拷贝non-static数据。仅当类没有用户定义的拷贝构造时才生成。如果类声明了移动操作它就是delete的。当用户声明了拷贝赋值或者析构，该函数自动生成已被废弃。
    //拷贝赋值运算符：和C++98运行时行为一样：逐成员拷贝赋值non-static数据。仅当类没有用户定义的拷贝赋值时才生成。如果类声明了移动操作它就是delete的。当用户声明了拷贝构造或者析构，该函数自动生成已被废弃。
    //移动构造函数和移动赋值运算符：都对非static数据执行逐成员移动。仅当类没有用户定义的拷贝操作，移动操作或析构时才自动生成。


    {
        //只声明构造函数和析构函数(编译器会自动生成拷贝构造和拷贝移动)
        onlyDestructor a;
        onlyDestructor c{std::move(a)};
        onlyDestructor b{a};
        
    }


    {
        //Rule of three
        //如果你声明了拷贝构造函数，拷贝赋值运算符，或者析构函数三者之一，你应该也声明其余两个。它来源于长期的观察，即用户接管拷贝操作的需求几乎都是因为该类会做其他资源的管理，这也几乎意味着
        //（1）无论哪种资源管理如果在一个拷贝操作内完成，也应该在另一个拷贝操作内完成
        //（2）类的析构函数也需要参与资源的管理（通常是释放）。通常要管理的资源是内存，这也是为什么标准库里面那些管理内存的类（如会动态内存管理的STL容器）都声明了“the big three”：拷贝构造，拷贝赋值和析构。

        //所以析构，拷贝构造，拷贝移动一般情况下都会同时出现
    }

    return 0;
}