Single_1 在单线程下没有问题，但是在多线程下因为涉及共享数据修改，所以存在静态条件，会有问题，可能new出来多个实例。

Single_2 使用了锁来保证线程安全，效率不高，代码中有一个可以提升的点是，可以先判断inst是否为空，不为空直接返回，这样避免一进来就加锁，代码不再补充。

Single_3 使用了静态局部变量，C++11之后保证静态局部变量的初始化是线程安全的，所以直接返回此引用即可。


再解释几个名词：

1.饿汉模式，程序运行后就创建一个实例，无论是否使用，可能会造成浪费，而且实例的创建时间并不为我们控制。

2.懒汉模式，在尝试获取单例时才创建，也是我们上面三种提到的方法。