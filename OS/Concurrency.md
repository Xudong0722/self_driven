# 进程和线程

进程是具有一定独立功能的程序关于某个数据集合的一次运行活动，进程是操作系统进行资源分配和调度的一个独立单位；它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体，它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。

线程是进程的一个实体，是cpu调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。他们之间的关系有：

1. 一个程序至少有一个进程，一个进程至少有一个线程；线程是指进程内的一个执行单元，也是进程内的可调度实体。资源分配给进程，同一进程的所有线程共享该进程的所有资源；
2. 一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行，相对于进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列.
3. 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。


## High Concurrency

提到进程和线程，就离不开多线程编程，并发并行这些概念，我们知道，在早期单核的机器上，如果CPU有多个任务要执行的话，会有不同的选择，CPU可以依次执行每个程序，当一个程序完成后再执行下一个程序，这种执行方式我们称串行；CPU也可以给按时间片切换程序，这样在一个时间段内，我们会发现所有程序都在运行，但是在一个时刻只有一个程序在运行，这种执行方式我们称并发，即多任务在一个时间段内交替执行；并行是多个程序在同一个时刻都在运行的现象，那显然，他要求我们的处理器是多核的。

在我们的日常工作生活中，经常碰到高并发，高性能，高可用这些名词，那么他们实际表达什么含义呢？
我们其实已经知道了并发是什么意思，高并发其实是泛化的一个概念，一般指在一个时间可以处理大量请求的能力，如双十一，大促活动秒杀等。
既然是能力，一定有衡量的指标，下面是衡量一个系统高并发能力的指标：

- QPS(Queries-per-second) 即每秒查询率，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准
- TPS(Transactions Per Second) 即服务器每秒处理的事务数。1）用户请求服务器 2）服务器自己的内部处理 3）服务器返回给用户。服务器每秒能够完成N个这三个过程，Tps也就是N；
- RT(Response Time) 从客户端请求发起到服务器响应结果的时间。RT的大小直接反应了当前系统的响应状态。基本和用户体验息息相关。

高并发有两种设计思路：
  
1. 竖向扩展
   1. 提升硬件，升级机器，提升核心数，存储，贷款...
   2. 改善程序架构，应用多线程，解决程序本身的性能瓶颈
2. 横向扩展
   1. 分布式集群，这个理论上没有上限，只要做好层次和服务划分，加机器扩容就能满足需求，但实际上并非如此，一方面分布式会增加系统复杂性，另一方面集群规模上去之后，也会引入一堆AIOps、服务发现、服务治理的新问题。
   2. 负载均衡，负载均衡就是把负载（request）均衡分配到不同的服务实例，利用集群的能力去对抗高并发，负载均衡是服务集群化的实施要素，有如下：
      1. DNS负载均衡，客户端通过URL发起网络服务请求的时候，会去DNS服务器做域名解释，DNS会按一定的策略（比如就近策略）把URL转换成IP地址，同一个URL会被解释成不同的IP地址，这便是DNS负载均衡，它是一种粗粒度的负载均衡，它只用URL前半部分，因为DNS负载均衡一般采用就近原则，所以通常能降低时延，但DNS有cache，所以也会更新不及时的问题。
      2. 硬件负载均衡，通过布置特殊的负载均衡设备到机房做负载均衡，比如F5，这种设备贵，性能高，可以支撑每秒百万并发，还能做一些安全防护，比如防火墙。
      3. 软件负载均衡，根据工作在ISO 7层网络模型的层次，可分为四层负载均衡（比如章文嵩博士的LVS）和七层负载均衡（NGINX），软件负载均衡配置灵活，扩展性强，阿某云的SLB作为服务对外售卖，Nginx可以对URL的后半部做解释承担API网关的职责。
   3. 数据库-分库分表+读写分离，把一个库分成多个库，部署在多个数据库服务上，主库承载写请求，从库承载读请求。从库可以挂载多个，因为很多场景写的请求远少于读的请求，这样就把对单个库的压力降下来了。如果写的请求上升就继续分库分表，如果读的请求上升就挂更多的从库，但数据库天生不是很适合高并发，而且数据库对机器配置的要求一般很高，导致单位服务成本高。
   4. 避免挤兑-流控，主要有四个算法：
      1. 计数器算法（固定窗口）：计数器算法是使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略，下一个周期开始时，进行清零，重新计数，实现简单。计数器算法方式限流对于周期比较长的限流，存在很大的弊端，有严重的临界问题。
      2. 滑动窗口算法：将时间周期分为N个小周期，分别记录每个小周期内访问次数，并且根据时间滑动删除过期的小周期，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。此算法可以很好的解决固定窗口算法的临界问题。
      3. 漏桶算法：访问请求到达时直接放入漏桶，如当前容量已达到上限（限流值），则进行丢弃（触发限流策略）。漏桶以固定的速率进行释放访问请求（即请求通过），直到漏桶为空。分布式环境下实施难度高。
      4. 令牌桶算法：程序以r（r=时间周期/限流值）的速度向令牌桶中增加令牌，直到令牌桶满，请求到达时向令牌桶请求令牌，如获取到令牌则通过请求，否则触发限流策略。分布式环境下实施难度高。



## High Performance
高性能是指系统能够在有限的资源下，以较快的速度响应用户的请求。高性能的实现需要考虑到系统的架构设计、算法优化、资源利用等方面。在系统架构设计上，可以采用分布式架构、微服务架构等来提高系统的并行处理能力。算法优化可以通过优化查询算法、缓存策略等来提高系统的响应速度。资源利用方面，可以通过合理的资源管理、内存优化等来提高系统的性能。


## High Availability
高可用（High availability，即 HA）的主要目的是为了保障业务的连续性，即在用户眼里，业务永远是正常（或者说基本正常）对外提供服务的。高可用的实现需要考虑到系统的容错性、故障恢复能力、监控和告警机制等方面。容错性可以通过冗余设计、备份和恢复机制等来提高系统的可用性。故障恢复能力可以通过快速检测和处理故障，减少系统的停机时间。监控和告警机制可以实时监测系统的运行状态，及时发现并解决潜在的问题。
