# Memory

在工作生活中，我们经常会碰到一个概念-内存，以及在业务中遇到的各种与之相关的问题，如内存溢出，内存泄漏，他们到底是什么，我们如何避免，如何解决，本文基于此问题为基础作一个学习的记录。


## What's Memory?
 随机访问存储器(Random-access-memory) 是与中央处理器直接交换数据的内存存储器，也称内存储器和主存储器，它用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。它是外存与CPU进行沟通的桥梁，计算机中所有程序的运行都在内存中进行，内存性能的强弱影响计算机整体发挥的水平。只要计算机开始运行，操作系统就会把需要运算的数据从内存调到CPU中进行运算，当运算完成，CPU将结果传送出来。


事实上，在早期，CPU是直接来访问物理内存的，如单片机，那么显然CPU一个时间段只能运行一个程序，否则，两个程序同时访问同一个物理地址会引发错误，所以地址空间的概念被提出，即虚拟地址，OS为每个进程都提供一个进程空间，进程空间里访问的地址都是虚拟地址，在访问虚拟地址时，会由内存管理单元将其转换为物理地址，这样，不同进程之间就不会发生冲突了。

## What's Memory Leak?

应用程序运行时，可能会不停地申请内存，比如，我们需要程序中构造了一个较大的对象，我们为了更好的控制这个对象的声明周期，会申请堆上的内存来存储这个对象，不同语言对于对象生命周期管理的支持不一样，比如，对于C/C++来说，malloc/free，new/delete总是一起出现的，由我们自己申请分配的内存在我们不需要时需要我们手动释放，否则这一段内存就会处于被程序持有但实际上程序内已经不需要使用的窘镜，即内存泄漏。

```c++
#include<iostream>
#include <string>

class Data{
private:
    std::string str;
    static int cnt;
public:
    Data(std::string&& _str): str(std::move(_str)){
        std::cout << "Total cnt:" << ++cnt << '\n'; 
    }
};

int Data::cnt = 0;

int main()
{
    while(true){
        Data* data = new Data{std::string(100000,'a')};
        //do something with data
    }
    return 0;
}
```

上面一个例子简单的展示了C++中内存泄漏的情况，在每次使用完`data`，没有显示释放`data`，造成内存泄漏，随着程序的运行，由于堆上被这些没有用到的对象占满，我们之后再去申请内存就会失败，造成程序异常退出。运行上面代码的结果如下：

```c++
...
Total cnt:20942
Total cnt:20943
Total cnt:20944
Total cnt:20945
Total cnt:20946
terminate called after throwing an instance of 'std::bad_alloc'
  what():  std::bad_alloc
```


我们只需要在使用完data之后，增加一个语句`delete data;`即可，而对于Java这种支持GC(Garbage Collection)的语言，虚拟机检测到分配的内存不会被使用后，会回收这些内存空间，但是这并不意味着Java程序不会发生内存泄漏，以下是查阅资料得到的常见的Java程序中内存泄漏的场景：

1. 长生命周期对象持有短生命周期对象的引用：如果一个长生命周期的对象持有对一个短生命周期对象的引用，即使短生命周期对象已经不再使用，它也无法被回收，从而导致内存泄露。
2. 静态集合类持有对象的引用：如果一个对象被添加到一个静态集合类（如 HashMap 或 ArrayList）中，即使该对象不再被使用，它仍然会被集合类持有的引用所保留，无法被回收。
3. 未正确关闭资源：当使用需要手动关闭的资源（如文件流、数据库连接、网络连接）时，如果忘记在使用完毕后显式地关闭资源，这些资源可能会一直被占用而无法释放，从而导致内存泄露。
4. 循环引用：如果存在两个或多个对象之间的相互引用，并且这些对象都不再被外部引用所持有，那么它们将无法被回收。


## What's Out of Memory?
Out of Memory- 内存泄漏指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。此时程序就运行不了，系统会提示内存溢出，造成程序崩溃。实际上，内存溢出是内存泄漏的一个结果，比如上面例子中的C++程序，在第20847次申请分配内存时程序发生异常`bad_alloc`，即分配内存失败，原因就是大量未使用的内存没有释放，再申请内存时由于可用内存不足以程序使用，所以程序抛出了异常，即发生了内存溢出。


## How to avoid crash caused by memory issue?

- 对于开发来说，要控制好程序中所有对象的生命周期。
- 做好测试，监测程序运行时堆栈大小的情况，是否符合预期，是否有异常升高情况。
- 利用内存泄漏分析工具，来分析程序的内存情况，以及是否有性能瓶颈。


